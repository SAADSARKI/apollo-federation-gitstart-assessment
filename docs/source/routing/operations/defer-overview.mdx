---
title: Overview of @defer directive support 
subtitle: Improve performance by delivering fields incrementally
description: Improve your GraphQL query performance with GraphOS Router and Apollo Router Core's support for the @defer directive. Incrementally deliver response data by deferring certain fields.
minVersion: 1.8.0
---

Apollo Router's support of the `@defer` directive helps client developers tackle the common challenge of how to create a responsive user experience when certain fields of a query take longer to resolve than others. `@defer` improves application performance by delivering response data incrementally. This is important for real-time applications like dashboards or reports. By deferring data for some fields, the router can resolve and return data for the query's _other_ fields more quickly, improving responsiveness.

## What is `@defer`?

The `@defer` directive enables a client query to specify sets of fields that it doesn't need to receive data for _immediately_. This is helpful whenever some fields in a query take much longer to resolve than others.

The `@defer` directive is applied to a GraphQL query. Specifically, deferred fields are always contained within a GraphQL fragment, and the `@defer` directive is applied to that fragment.

Here's an example query that uses `@defer`:

```graphql
query GetTopProducts {
  topProducts {
    id
    name
    # highlight-start
    ... @defer {
      price
    }
    # highlight-end
  }
}
```

To respond incrementally, the router uses a multipart-encoded HTTP response. To use `@defer` successfully with the router, a client's GraphQL library must _also_ support the directive by handling multipart HTTP responses correctly.

The router's `@defer` support is compatible with all [federation-compatible subgraph libraries](/federation/building-supergraphs/supported-subgraphs/). That's because the router takes advantage of your supergraph's existing [entities](/federation/entities/) to fetch any deferred field data via followup queries to your subgraphs.


## Which fields can my router defer?

Your router can defer the following fields in your schema:

- Root fields of the `Query` type (along with their subfields)
- Fields of any entity type (along with their subfields)
  - Deferring entity fields is extremely powerful but requires some setup if you aren't using entities already. This is covered in more detail [below](#entity-fields).

See below for more information on each of these.

### `Query` fields

Your router can defer any field of your schema's `Query` type, along with any subfields of those fields:

```graphql
query GetUsersAndDeferProducts {
  users {
    id
  }
  # highlight-start
  ... @defer {
    products {
      id
    }
  }
  # highlight-end
}
```

With the query above, the router first returns a list of `User` IDs, then later completes the response with a list of `Product` IDs.

### Entity fields

Your router supports deferring fields of the special object types in your supergraph called entities.

Entities are object types that often define their fields across multiple subgraphs (but they don't have to). You can identify an entity by its use of the `@key` directive. In the example subgraph schemas below, the `Product` type is an entity:

<CodeColumns>

```graphql title="Products subgraph"
type Product @key(fields: "id") {
  id: ID!
  name: String!
  price: Int!
}

type Query {
  topProducts: [Product!]!
}
```

```graphql title="Reviews subgraph"
type Product @key(fields: "id") {
  id: ID!
  reviews: [Review!]!
}

type Review {
  score: Int!
}
```

</CodeColumns>

Entities are query entry points into your subgraphs, and this is what enables your router to defer their fields: the router can send a followup query to a subgraph to fetch any entity fields that it doesn't fetch initially.

Here's an example query that defers entity fields using the subgraphs above:

```graphql
query GetProductsAndDeferReviews {
  topProducts {
    id
    name
    # highlight-start
    ... @defer {
      reviews {
        score
      }
    }
    # highlight-end
  }
}
```

To handle this query, the router first resolves and returns a list of `Product` objects with their IDs and names. Later, the router completes the response by returning review scores for each of those products.

<Note>

It doesn't matter which subgraph defines a particular entity field! Queries can defer entity fields that are defined across any number of different subgraphs.

</Note>

### Defining entities in your subgraphs

If your subgraphs don't yet include any entities, you need to define some before clients can start deferring their fields in queries.

To learn about creating entities, see [this guide](/graphos/schema-design/federated-schemas/entities).

## Next steps

- [Configure your router](/graphos/routing/operations/defer) and clients to enable and handle `@defer`
